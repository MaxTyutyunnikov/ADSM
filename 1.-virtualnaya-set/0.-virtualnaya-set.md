В <a href="https://linkmeup.ru/blog/424.html" target="_blank">предыдущем выпуске</a> я описал фреймворк сетевой автоматизации. По отзывам у некоторых людей даже этот первый подход к проблеме уже разложил некоторые вопросы по полочкам. И это очень меня радует, потому что наша цель в цикле - не обмазать питоновскими скриптами анзибль, а выстроить систему.

Этот же фреймворк задаёт порядок, в котором мы будем разбираться с вопросом.
И виртуализация сети не особо укладывается в тематику АДСМ, где мы разбираем автоматику. Но без неё может не сложиться понимания, почему сеть выглядит так, как я её буду описывать в следующей статье.
Поэтому сейчас мы сделаем небольшой шаг в сторону.

<a href="https://fs.linkmeup.ru/images/adsm/1/kdpv.jpg" target="_blank"><img src="https://fs.linkmeup.ru/images/adsm/1/kdpv.jpg" width="800"></a>

<cut>

<h1>Содержание</h1>
<ul>
    <li><b><a href="#REASONS">Причины</a></b></li>
    <li><b><a href="#GLOSSARY">Терминология</a></b></li>
    <li><b><a href="#UNDERLAY">Underlay - физическая сеть</a></b></li>
    <li><b><a href="#OVERLAY">Overlay - виртуальная сеть</a></b>
    <ul>
        <li><a href="#TF">На примере Tungsten Fabric</a>
        <ul>
            <li><a href="#INTRA_HV">Коммуникация внутри одной физической машины</a></li>
            <li><a href="#INTER_HV">Коммуникация между ВМ, расположенными на разных физических машинах</a></li>
            <li><a href="#EXTERNAL">Выход во внешний мир</a></li>
        </ul>
        </li>
    </ul>
    </li>
    <li><b><a href="#THEEND">Заключение</a></b></li>
    <li><b><a href="#LINKS">Полезные ссылки</a></b></li>
</ul>
<hr>

<li><a name="REASONS"></a>
<h1>Причины</h1>
И раз уж мы об этом заговорили, то стоит упомянуть предпосылки к виртуализации сети. На самом деле этот процесс начался не вчера. 

Наверно, вы не раз слышали, что сеть всегда была самой инертной частью любой системы. И это правда во всех смыслах. Сеть - это базис, на который опирается всё, и производить изменения на ней довольно сложно - сервисы не терпят, когда сеть лежит. Зачастую вывод из эксплуатации одного узла может сложить большую часть приложений и повлиять на много клиентов. Отчасти поэтому сетевая команда может сопротивляться любым изменениям - потому что сейчас оно как-то работает (<i>мы, возможно, даже не знаем как</i>), а тут надо что-то новое настроить, и неизвестно как оно повлияет на сеть.

Чтобы не ждать, когда сетевики прокинут VLAN и любые сервисы не прописывать на каждом узле сети, люди придумали использовать оверлеи - наложенные сети - коих великое многообразие: GRE, IPinIP, MPLS, MPLS L2/L3VPN, VxLAN, EVPN, MPLSoverUDP, MPLSoverGRE итд.

Их привлекательно заключается в двух простых вещах:
    - Настраиваются только конечные узлы - транзитные трогать не приходится. Это значительно ускоряет процесс, а иногда вообще позволяет исключить отдел сетевой инфраструктуры из процесса ввода новых сервисов.
    - Нагрузка сокрыта глубоко внутри заголовков - транзитным узлам не нужно ничего знать о ней, об адресации на хостах, маршрутах наложенной сети. А это значит, нужно хранить меньше информации в таблицах, значит взять попроще/подешевле устройство.

В этом не совсем полноценном выпуске я не планирую разбирать все возможные технологии, а скорее описать фреймворк работы оверлейных сетей в ДЦ.

Вся серия будет описывать датацентр, состоящий из рядов однотипных стоек, в которых установлено одинаковое серверное оборудование. 
На этом оборудовании запускаются виртуальные машины/контейнеры/серверлесс, реализующие сервисы.



<img src="https://fs.linkmeup.ru/images/adsm/1/dc.jpg" width="800">

<hr>

<a name="GLOSSARY"></a>
<h1>Терминология</h1>
В цикле <b>сервером</b> я буду называть программу, которая реализует серверную сторону клиент-серверной коммуникации.
Физические машины в стойках называть серверами <b>не</b> будем.

<b>Физическая машина</b> - x86-компьютер, установленный в стойке. Наиболее часто употребим термин <b>хост</b>. Так и будем называть её "<b>машина</b>" или <b>хост</b>.

<b>Гипервизор</b> - приложение, запущенное на физической машине, эмулирующее физические ресурсы, на которых запускается Виртуальная Машина.

<b>Виртуальная машина</b> - операционная система, запущенная на физической машине поверх гипервизора. Для нас в рамках данного цикла не так уж важно, на самом ли деле это виртуальная машина или просто контейнер. Будем называть это"<b>ВМ</b>"

<b>ToR - Top of the Rack switch</b> - коммутатор, установленный в стойке, к которому подключены все физические машины.
<blockquote>
    Кроме топологии ToR, разные провайдеры практикуют End of Row (EoR) или Middle of Row (хотя последнее - пренебрежительная редкость и аббревиатуры MoR я не встречал).
</blockquote>

<b>Underlay network</b> или подлежащая сеть или андэрлей - физическая сетевая инфраструктура: коммутаторы, маршрутизаторы, кабели.
<b>Overlay network</b> или наложенная сеть или оверлей - виртуальная сеть туннелей, работающая поверх физической.
<b>L3-фабрика или IP-фабрика</b> - потрясающее изобретение человечества, позволяющее к собеседованиям не повторять STP и не учить TRILL. Концепция, в которой вся сеть вплоть до уровня доступа исключительно L3, без VLAN и соответственно огромных растянутых широковещательных доменов. Откуда тут слово "фабрика" разберёмся в следующей части.



<img src="https://fs.linkmeup.ru/images/adsm/1/terminology.png" width="700">

<blockquote>
    Я сейчас намеренно упрощаю описание до конкретной реализации, чтобы сильно не запутывать читателя. Для более вдумчивого чтения отсылаю его к секции <a href="#LINKS">Ссылки</a>. Кроме того, Рома Горге, критикующий данную статью за неточности, обещает написать отдельный выпуск о технологиях виртуализации серверов и сетей, более глубокую и внимательную к деталям.
</blockquote>

<hr>

Большинство сетей сегодня можно явно разбить на две части: 
<b>Underlay</b> - физическая сеть со стабильной конфигурацией.
<b>Overlay</b> - абстракция над Underlay. 
Это верно, как для случая ДЦ (VxLAN), который мы разберём в будущем, так и для ISP (MPLS L3VPN). С энтерпрайзными сетями, конечно, ситуация несколько иная. 

Картинка с фокусом на сеть:

<img src="https://fs.linkmeup.ru/images/adsm/1/fabric.png" width="800">

<hr>

<a name="UNDERLAY"></a>
<h1>Underlay</h1>
Underlay - это физическая сеть: аппаратные коммутаторы и кабели. Устройства в андерлее знают, как добраться до физических машин.


<img src="https://fs.linkmeup.ru/images/adsm/1/underlay.png" width="800">

Опирается он на стандартные протоколы и технологии. Не в последнюю очередь потому, что аппаратные устройства по сей день работают на проприетарном ПО, не допускающем ни программирование чипа, ни реализацию своих протоколов, соответственно, нужна совместимость с другими вендорами и стандартизация.
<blockquote>
А вот кто-нибудь вроде Гугла может себе позволить разработку собственных коммутаторов и отказ от общепринятых протоколов. Но LAN_DC не Гугл.
</blockquote>

Underlay сравнительно редко меняется, потому что его задача - базовая IP-связность между физическими машинами. Underlay ничего не знает о запущенных поверх него сервисах, клиентах, тенантах - ему нужно только доставить пакет от одной машины до другой.
Underlay может быть например таким: 
<ul>
    <li>IPv4+OSPF
    Или</li> 
    <li>IPv6+ISIS+BGP+L3VPN
    Или</li>
    <li>L2+TRILL
    Или</li>
    <li>L2+STP</li>
</ul>
Настраивается Underlay'ная сеть классическим образом: CLI/GUI/NETCONF.
Вручную, скриптами, проприетарными утилитами.

Более подробно андерлею будет посвящена следующая статья цикла.
<hr>

<a name="OVERLAY"></a>
<h1>Overlay</h1>
Overlay - виртуальная сеть туннелей, натянутая поверх Underlay, она позволяет ВМ одного клиента общаться друг с другом, при этом обеспечивая изоляцию от других клиентов.


<img src="https://fs.linkmeup.ru/images/adsm/1/overlay.png" width="800">

Так ВМ одного клиента (одного сервиса) могут общаться друг с другом через Overlay, даже не подозревая какой на самом деле путь проходит пакет. 
Overlay может быть например таким, как уже я упоминал выше:
<ul>
    <li>GRE-туннель</li>
    <li>VxLAN</li>
    <li>EVPN</li>
    <li>L3VPN</li>
</ul>
Overlay обычно настраивается и поддерживается через центральный контроллер. С него конфигурация, Control Plane и Data Plane доставляются на конечные виртуальные устройства.
<b>Да, это SDN в чистом виде. </b>

<ul>
<li>
    Overlay может начинаться на коммутаторе доступа (ToR), стоящем в стойке, как это происходит, например, в случае VxLAN-фабрики. Тогда коммутатор должен уметь разделять различные сервисы, соответственно, сетевой администратор должен в известной степени сотрудничать с администраторами виртуальных машин и вносить изменения (пусть и автоматически) в конфигурацию устройств.
    Тут я отошлю читателя к статье о <a href="https://habr.com/ru/post/344326/" target="_blank">VxLAN на хабре</a> нашего старого друга <a href="https://habr.com/ru/users/bormoglotx/" target="_blank">@bormoglotx</a>.
    А для более полного погружения в реалии, можно почитать цискину книгу <a href="https://www.cisco.com/c/dam/en/us/td/docs/switches/datacenter/nexus9000/sw/vxlan_evpn/VXLAN_EVPN.pdf" target="_blank">A Modern, Open, and Scalable Fabric: VXLAN EVPN</a>.
</li>
<li>
    Другой подход - начинать и терминировать туннели на конечных хостах.
    В этом случае сеть (Underlay) остаётся максимально простой и статичной.
    А хост сам делает все необходимые инкапсуляции.
    Для этого потребуется, безусловно, запускать специальное приложение на хостах, но оно того стоит. 
    Во-первых, запустить клиент на linux-машине проще или, скажем так, - вообще возможно - в то время как на коммутаторе, скорее всего, придётся пока обращаться к проприетарным SDN-решениям, что убивает идею мультивендорности.
    Во-вторых, ToR-коммутатор в этом случае можно оставить максимально простым, как с точки зрения Control Plane'а, так и Data Plane'а. Действительно - с SDN-контроллером ему тогда общаться не нужно, и хранить сети/ARP'ы всех подключенных клиентов - тоже - достаточно знать IP-адрес физической машины, что кратно облегчает таблицы коммутации/маршрутизации.
</li>
</ul>
<hr>

Проще всего рассмотреть на примерах. И в качестве подопытного мы возьмём OpenSource'ную SDN платформу OpenContrail, ныне известную как <a href="https://tungsten.io" target="_blank">Tungsten Fabric</a>.
<blockquote>
    В <a href="#VSWITCH">конце статьи</a> я приведу некоторые размышления на тему аналогии с OpenFlow и OpenvSwitch.
</blockquote>

<a name="TF"></a>
<h2>На примере Tungsten Fabric</h2>
На каждой физической машине есть <b>vRouter</b> - виртуальный маршрутизатор, который знает о подключенных к нему сетях и каким клиентам они принадлежат - по сути - PE-маршрутизатор. Для каждого клиента он поддерживает изолированную таблицу маршрутизации (читай VRF). И собственно vRouter делает Overlay'ное туннелирование.
Каждая ВМ, расположенная на гипервизоре, соединяется с vRouter'ом этой машины через <b>TAP-интерфейс</b>.

!!! Проверить картинки vm-0, vm-1


<img src="https://fs.linkmeup.ru/images/adsm/1/tf-host.png" width="500">

Если за vRouter'ом находится несколько сетей, то для каждой из них создаётся виртуальный интерфейс, на который назначается IP-адрес - он будет адресом шлюза по умолчанию.
Все сети одного клиента помещаются в один <b>VRF</b> (одну таблицу), разных - в разные.

Чтобы vRouter'ы могли общаться друг с другом, а соответственно и ВМ, находящиеся за ними, они обмениваются маршрутной информацией через SDN-контроллер.


<a href="https://fs.linkmeup.ru/images/adsm/1/sdn-controller.png" target="_blank"><img src="https://fs.linkmeup.ru/images/adsm/1/sdn-controller.png" width="900"></a>

Чтобы выбраться во внешний мир, существует точка выхода из матрицы - шлюз виртуальной сети VNGW - Virtual Network GateWay (<i>термин мой</i>).


<a href="https://fs.linkmeup.ru/images/adsm/1/vngw.png" target="_blank"><img src="https://fs.linkmeup.ru/images/adsm/1/vngw.png" width="900"></a>

<hr>

Теперь рассмотрим примеры коммуникаций - и будет ясность.

<a name="INTRA_HV"></a>
<h3>Коммуникация внутри одной физической машины</h3>
VM0 хочет отправить пакет на VM2. Предположим пока, что это ВМ одного клиента.

<h4>Data Plane</h4>
У VM-0 есть маршрут по умолчанию в его интерфейс eth0. Пакет отправляется туда.
Этот интерфейс eth0 на самом деле виртуально соединён с виртуальным маршрутизатором vRouter через TAP-интерфейс tap0.
vRouter анализирует на какой интерфейс пришёл пакет, то есть к какому клиенту (VRF) он относится, сверяет адрес получателя с таблицей маршрутизации этого клиента.
Обнаружив, что получатель на этой же машине за другим портом, vRouter просто отправляет пакет в него без каких-либо дополнительных заголовков - на этот случай на vRouter'е уже есть ARP-запись. 


<img src="https://fs.linkmeup.ru/images/adsm/1/intra-hv-dp.png" width="700">

Пакет в этом случае не попадает в физическую сеть - он смаршрутизировался внутри vRouter'а.

<a name="INTRA_HV_CP"></a>
<h4>Control Plane</h4>
Гипервизор при запуске виртуальной машины сообщает ей:
<ul>
    <li>Её собственный IP-адрес.</li>
    <li>Маршрут по умолчанию - через IP-адрес vRouter'а в этой сети.</li>
</ul>

vRouter'у через специальный API гипервизор сообщает:
<ul>
    <li>Что нужно создать виртуальный интерфейс.</li>
    <li>Какому клиенту (VRF) принадлежит этот интерфейс.</li>
    <li>Статическую ARP-запись для этой VM - за каким интерфейсом находится её IP-адрес и к какому MAC-адресу он привязан.</li>
</ul>
<blockquote>
    И снова, реальная процедура взаимодействия упрощена в угоду понимания концепции.
</blockquote>


<img src="https://fs.linkmeup.ru/images/adsm/1/intra-hv-cp.png" width="800">

Таким образом все ВМ одного клиента на данной машине vRouter видит как непосредственно подключенные сети и может сам между ними маршрутизировать.
<hr>

А вот VM0 и VM1 принадлежат разным клиентам, соответственно, находятся  в разных таблицах vRouter'а.
Смогут ли они друг с другом общаться напрямую, зависит от настроек vRouter и дизайна сети.
Например, если ВМ обоих клиентов используют публичные адреса, или NAT происходит на самом vRouter'е, то можно сделать и прямую маршрутизацию на vRouter.

В противной же ситуации возможно пересечение адресных пространств - нужно ходить через NAT-сервер, чтобы получить публичный адрес - это похоже на выход во внешние сети, о которых <a href="#EXTERNAL">ниже</a>.
<hr>

<a name="INTER_HV"></a>
<h3>Коммуникация между ВМ, расположенными на разных физических машинах</h3>
<h4>Data Plane</h4>
Начало точно такое же: VM-0 посылает пакет с адресатом VM-7 (172.17.3.2!!!) по своему дефолту.
vRouter его получает и на этот раз видит, что адресат находится на другой машине и доступен через туннель Tunnel0.
Сначала он вешает метку MPLS, идентифицирующую VRF (клиента), чтобы на обратной стороне vRouter мог определить куда этот пакет поместить.


<a href="https://fs.linkmeup.ru/images/adsm/1/inter-hv-dp.png" target="_blank"><img src="https://fs.linkmeup.ru/images/adsm/1/inter-hv-dp.png" width="1000"></a>

У Tunnel0 источник 10.0.0.2, получатель: 10.0.1.2.
vRouter добавляет заголовки GRE (или <a href="#UDPVSGRE">UDP<a>) и новый IP к исходному пакету.
В таблице маршрутизации vRouter есть маршрут по умолчанию через адрес ToR1 10.0.0.1. Туда и отправляет.


<img src="https://fs.linkmeup.ru/images/adsm/1/headers.png" width="700">

ToR1 как участник Underlay сети знает (например, по OSPF), как добраться до 10.0.1.2, и отправляет пакет по маршруту.
При этом знать, что находится под внешним заголовком IP ему не нужно. То есть фактически под IP может быть бутерброд из IPv6 over MPLS over Ethernet over MPLS over GRE over over over Грека.
Соответственно на принимающей стороне vRouter снимает GRE и по MPLS-метке понимает, какому клиенту этот пакет надо передать, раздевает его и отправляет в первоначальном виде получателю.

<a name="INTER_HV_CP"></a>
<h4>Control Plane</h4>
Происходит всё то же, что было описано <a href="#INTRA_HV_CP">выше</a>.
И плюс ещё следующее:
<ul>
    <li>Для каждого клиента vRouter выделяет MPLS-метку. Это сервисная метка L3VPN, по которой клиенты будут разделяться в пределах одной физической машины.</li>
    <li>vRouter устанавливает соединение с SDN-контроллером по протоколу BGP (или похожему на него - в случае TF -это XMPP 0_o).</li>
    <li>Через эту сессию vRouter сообщает SDN-контроллеру маршруты до подключенных сетей:
    <ul>
        <li>Адрес сети</li>
        <li>Метод инкапсуляции (MPLSoGRE, MPLSoUDP)</li>
        <li>MPLS-метка клиента</li>
        <li>Свой IP-адрес в качестве nexthop</li>
    </ul>
    </li>
    <li>SDN-контроллер получает такие маршруты ото всех подключенных vRouter'ов, и отражает их другим. То есть он выступает Route Reflector'ом.</li>
</ul>

То же самое происходит и в обратную сторону.


<a href="https://fs.linkmeup.ru/images/adsm/1/inter-hv-cp.png" target="blank" target="_blank"><img src="https://fs.linkmeup.ru/images/adsm/1/inter-hv-cp.png" width="1000"></a>

Overlay может меняться хоть каждую минуту. Примерно так это и происходит в публичных облаках, когда клиенты регулярно запускают и выключают свои виртуальные машины.
Центральный контроллер берёт на себя все сложности с поддержанием конфигурации и контролем таблиц коммутации/маршрутизации на vRouter.
Если говорить грубо, то контроллер запиривается со всеми vRouter'ами по BGP (или похожему на него протоколу) и просто передаёт маршрутную информацию. BGP, например, уже имеет Address-Family для передачи метода инкапсуляции <a href="https://tools.ietf.org/html/rfc4023">MPLS-in-GRE</a> или <a href="https://tools.ietf.org/html/rfc7510">MPLS-in-UDP</a>.

При этом не меняется никоим образом конфигурация Underlay-сети, которую кстати, автоматизировать на порядок сложнее, а сломать неловким движением проще.
<hr>

<a name="EXTERNAL"></a>
<h3>Выход во внешний мир</h3>
Где-то симуляция должна закончиться, и из виртуального мира нужно выйти в реальный. И нужен <s>таксофон</s> шлюз.
Практикуют два подхода:
<ol>
    <li>Ставится аппаратный маршрутизатор.</li>
    <li>Запускается какой-либо appliance, реализующий функции маршрутизатора (да-да, вслед за SDN мы и с VNF столкнулись). Назовём его виртуальный шлюз.</li>
</ol>

<blockquote>
    Преимущество второго подхода в дешёвой горизонтальной масштабируемости - не хватает мощности - запустили ещё одну виртуалку со шлюзом. На любой физической машине, без необходимости искать свободные стойки, юниты, вывода питания, покупать саму железку, везти её, устанавливать, коммутировать, настраивать, а потом ещё и менять в ней сбойные компоненты.
    Минусы же у виртуального шлюза в том, что единица физического маршрутизатора всё же на порядки мощнее многоядерной виртуалки, а его софт, подогнанный под его же аппаратную основу, работает значительно стабильнее (<i>нет</i>). Сложно отрицать и тот факт, что программно-аппаратный комплекс просто работает, требуя только настройки, в то время как запуск и обслуживание виртуального шлюза - занятие для сильных инженеров.
</blockquote>

Одной своей ногой шлюз смотрит в виртуальную сеть Overlay, как обычная Виртуальная Машина, и может взаимодействовать со всеми другими ВМ. При этом она может терминировать на себе сети всех клиентов и, соответственно, осуществлять и маршрутизацию между ними.

Другой ногой шлюз смотрит уже в магистральную сеть и знает о том, как выбраться в Интернет.

<img src="https://fs.linkmeup.ru/images/adsm/1/two_legs.png" width="800">

<a name="EXTERNAL_DP"></a>
<h4>Data Plane</h4>
То есть процесс выглядит так: 
<ol>
    <li>VM-0, имея дефолт, отправляет пакет с адресатом во внешнем мире в интерфейс eth0.</li>
    <li>vRouter получает этот пакет. Вешает MPLS-метку данного клиента, полученную от контроллера (а тот получил от шлюза).</li>
    <li>Он знает так же от контроллера, что маршрут по умолчанию лежит через шлюз VNGW1 с IP-адресом 10.0.255.2!!!.</li>
    vRouter упаковывает первоначальный пакет в заголовок GRE и новый IP и отправляет на ToR1.</li>
    <li>Underlay доставляет пакет до шлюза VNGW1.</li>
    <li>Шлюз VNGW1 снимает туннелирующие заголовки (GRE/UDP, MPLS), при необходимости делает NAT-трансляцию, видит адрес назначения, консультируется со своей таблицей маршрутизации и понимает, что он направлен в Интернет - значит через Full View или Default.</li>
    <li>От VNGW до бордера может быть обычная IP-сеть, что вряд ли.
    Может быть классическая MPLS сеть (IGP+LDP/RSVP TE), может быть обратно фабрика с BGP LU или GRE-туннель от VNGW до бордера через IP-сеть.
    Как бы то ни было VNGW1 совершает необходимые инкапсуляции и отправляет первоначальный пакет в сторону бордера.</li>
</ol>



<a href="https://fs.linkmeup.ru/images/adsm/1/outside-dp.png" target="blank"><img src="https://fs.linkmeup.ru/images/adsm/1/outside-dp.png" width="1000"></a>

Трафик в обратную сторону проходит те же шаги в противоположном порядке. 
<ol>
    <li>Бордер добрасывает пакет до VNGW1</li>
    <li>Тот его раздевает, смотрит на адрес получателя и видит, что тот доступен через туннель Tunnel1 (MPLSoGRE или MPLSoUDP).</li>
    <li>Соответственно, вешает метку MPLS, заголовок GRE/UDP и отправляет на свой ToR2.
    Адрес назначения - IP-адрес vRouter'а, за которым стоит целевая ВМ.</li>
    <li>ToR2 знает, как добраться до этого адреса. </li>
    <li>Целевой vRouter снимает GRE/UDP, по MPLS-метке определяет клиента и шлёт голый IP-пакет в свой TAP-интерфейс, связанный с eth0 ВМ.</li>
</ol>

<a href="https://fs.linkmeup.ru/images/adsm/1/outside-dp-reverse.png" target="blank"><img src="https://fs.linkmeup.ru/images/adsm/1/outside-dp-reverse.png" width="1000"></a>

<a name="EXTERNAL_CP"></a>
<h4>Control Plane</h4>
VNGW1 устанавливает BGP-соседство с SDN-контроллером, от которого он получает всю маршрутную информацию о клиентах: за каким IP-адресом (vRouter'ом) находится какой клиент, и какой MPLS-меткой он идентифицируется.
Аналогично он сам SDN-контроллеру сообщает дефолтный маршрут с меткой, указывая себя в качестве nexthop'а.
Точно так же, как и другие ВМ между собой, между ВМ и VNGW трафик ходит инкапсулированным в MPLSoGRE (или MPLSoUDP).

То есть и тут SDN-контроллер выступает в роли Route-Reflector'а между VNGW и vRouter'ами.

На VNGW обычно происходит агрегация маршрутов или NAT-трансляция.
И в другую сторону в сессию с бордерами или Route Reflector'ами он отдаёт именно этот агрегированный маршрут. А от них получает маршрут по умолчанию или Full-View, или что-то ещё. 

<a href="https://fs.linkmeup.ru/images/adsm/1/outside-cp.pn" target="blank"><img src="https://fs.linkmeup.ru/images/adsm/1/outside-cp.png" width="1000"></a>

<hr>

<a name="THEEND"></a>
<h1>Заключение</h1>
А что там наш Underlay? 
А в общем-то ничего. Он всю дорогу не менялся. Всё, что ему нужно делать в Control Plane'е - это обновлять маршруты и ARP'ы по мере появления и исчезновения vRouter/VNGW и таскать пакеты между ними.
А именно - уметь в какой-то протокол маршрутизации.
Иметь широкую полосу, чтобы не терялись пакеты из-за перегрузок.
Уметь обеспечить QoS.

Работе самой Underlay-сети я посвятил здесь совсем мало времени. Это потому, что далее в серии я именно на ней и сосредоточусь, а Overlay мы будем затрагивать только вскользь.

Очевидно, я сильно ограничиваю нас всех, используя в качестве примера сеть ДЦ, построенную на фабрике Клоза с чистой IP-маршрутизацией и оверлеем с хоста.
Однако я уверен, что любую сеть, имеющую дизайн, можно описать в формальных терминах и автоматизировать. Просто я здесь преследую целью разобраться в подходах к автоматизации, а не запутать всех вообще, решая задачу в общем виде.

<a name="FAQ"></a>
<h1>FAQ</h1>
<a name="UDPVSGRE"></a>
<b>Зачем ты всё время делаешь ремарку GRE/UDP?</b>
Ну, вообще, это, можно сказать, специфично для Tungsten Fabric - можно вообще не брать во-внимание.
Но если брать, то сам TF, ещё будучи OpenContrail'ом поддерживал обе инкапсуляции: MPLS in GRE и MPLS in UDP. 
UDP хорош тем, что в Source Port в его заголовке очень легко закодировать хэш-функцию от изначальных IP+Proto+Port, что позволит делать балансировку. 
В случае GRE, увы, есть только внешние заголовки IP и GRE, которые одинаковы для всего инкапсулированного трафика и речь о балансировке не идёт - мало кто может заглянуть так глубоко внутрь пакета.

До некоторого времени маршрутизаторы, если и умели в динамические туннели, то только в MPLSoGRE, и только совсем недавно, научились в MPLSoUDP. Поэтому приходится делать всегда ремарку о возможности двух разных инкапсуляций.

Справедливости ради, стоит отметить, что TF вполне поддерживает и L2-связность с помощью VxLAN.

<a  name="VSWITCH"></a>
<b>Ты обещал провести параллели с OpenFlow.</b>
Они и правда напрашиваются. vSwitch в том же OpenStack'е делает весьма похожие вещи, используя VxLAN, у которого, кстати, тоже UDP-заголовок.
В Data Plane они работают примерно одинаково, существенно различается Control Plane. Tungsten Fabric использует XMPP для доставки информации о маршрутах на vRouter, в то время, как в OpenStack'е работает Openflow.

<b>А можно чуть больше про vRouter?</b>
Он делится на две части: vRouter Agent и vRouter Forwarder.
Первый запускается в User Space хостовой ОС и общается с SDN-контроллером, обмениваясь информацией о маршрутах, VRF и ACL.
Второй реализует Data Plane - обычно в Kernel Space, но может запускаться и на SmartNIC'ах - сетевых картах с CPU и отдельным программируемым чипом коммутации, что позволяет снять нагрузку с CPU хостовой машины, а сеть сделать быстрее и предсказуемее. 
vRouter Agent спускает настройки на vRouter Forwarder.


<a name="LINKS"></a>
<h1>Полезные ссылки</h1>
<a href="https://tungstenfabric.github.io/website/" target="_blank">Tungsten Fabric Archvitecture</a>
Ovs
Overlay networksx
vxlan