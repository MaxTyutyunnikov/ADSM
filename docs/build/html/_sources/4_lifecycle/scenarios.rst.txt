Сценарии
========
    
В реальной жизни их, конечно, будет много. Я же опишу самые необходимые:

* `1. Ввод нового оборудования`_
* `2. Переконфигурация из-за изменений переменных в инвентарной системе`_
* `3. Переконфигурация из-за изменения дизайна`_
* `4. Сбор информации с устройств`_
* `5. Снятие и возврат нагрузки`_
* `6. Обновление ПО`_
* `7. Удаление устройства`_
* `8. Замена устройства`_


    
Распишем каждый из них детально.

1. Ввод нового оборудования
---------------------------

В зависимости от скорости роста, возможно, самый важный сценарий - быстро запускать новые узлы (стойки, филиалы, офисы), поскольку обычно занимает больше всего времени.
#. | Человек или часть системы, реализующей нечто а-ля ZTP, приходит в NetAPI для инициализации устройства.

        .. figure:: https://fs.linkmeup.ru/images/adsm/4/step1.svg
               :width: 600
               :align: center

    #. Ручка дёргает конкретное приложение, отвечающее за этот шаг
    #. Приложение создаёт устройство в NetBox и прописывает его

            * Имя
            * Серийник
            * Локацию
            * Вендор/модель
            * Роль в сети
            * Присущие ему свойства: список интерфейсов, консольных портов, комментарии.

    #. Приложение определяет и при необходимости создаёт MGMT-интерфейс
    #. Приложение выделяет MGMT IP.
    
    | На данном шаге устройство в минимальном виде заведено в инвентарной системе, и заполнены необходимые для первичной настройки параметры.
    #. | Далее другая часть процесса, а-ля ZTP, приходит в ручку NetAPI в поисках первоначального конфига

        .. figure:: https://fs.linkmeup.ru/images/adsm/4/step2.svg
               :width: 700
               :align: center

        #. Ручка дёргает конкретное приложение
        #. Приложение собирает данные из NetBox и, возможно, внешних систем
        #. Приложение рендерит конфиг, возвращает его клиенту и заодно складывает его в git-репозиторий.
        #. Клиент каким-то образом доставляет конфигурацию до устройства - это может быть ZTP или пропихивание конфига через консольный порт.
    
       | После этого шага появляется удалённый SSH-доступ на устройство.
    
       | Теперь по какому-то триггеру запускается конвейер ввода устройства в эксплуатацию.
       | Триггером может быть:

        * Чьё-то ручное действие - например, нажатие кнопки в интерфейсе - и сигнал в NetAPI.
        * Обращение к ручке ввода в NetAPI от системы ZTP после завершения.
        * Факт появления доступа по SSH на устройство - например, кроняка пытается доступиться до железки, которая помечена как "для ввода".

#. Заполняются данные в NetBox, которые в дальнейшем будут служить переменными для генерации конфигурации.

            .. figure:: https://fs.linkmeup.ru/images/adsm/4/step3.svg
                   :width: 800
                   :align: center

    #. Система посылает в NetGet запрос на сбор данных о LLDP с данного свитча.

        #. Информация о соседях вносится в NetBox, порты связываются друг с другом.
        #. При необходимости создаются сабинтерфейсы или интерфейсы добавляются в LAG.
        #. | Вычисляются (или выделяются) P2P IP-адреса.
           | Необходимые изменения выполняются и на соседнем устройстве.
           | Этот шаг позволяет, во-первых, подготовить данные для настройки IP-адресов, во-вторых, визуализировать топологию при необходимости, в-третьих, собрать в будущем информацию о BGP-соседях, если на узле используется BGP.
        #. Система создаёт набор виртуальных интерфейсов и выделяет IP-адреса. Например, loopback'и и VLAN-интерфейсы.
        #. Заполняет другие необходимые данные. Например, ASN, IS-IS Network Entity, настройки l2-интерфейсов.
    #. | Обновление данных в NetBox инициирует запрос в NetAPI на запуск конвейера для вычисления и деплоя новой конфигурации. Это может быть, например, Web-hook, отправленный самим Netbox'ом.
       | Речь здесь идёт обо всех устройствах, конфигурация которых меняется в результате ввода новых устройств. Добавляется новый Leaf - поменяется конфигурация Spine.

            .. figure:: https://fs.linkmeup.ru/images/adsm/4/step4-7.svg
                   :width: 700
                   :align: center

    #. | NetAPI через Диспетчера адресует задачу на ConfMan, который вычисляет вендор-агностик конфигурацию.
       | Для этого система берёт формализованную модель конфигурации данных (питоновские объекты, yaml итд) и подставляет в неё данные из NetBox. 
       | Результатом может быть словарь, тот же yaml или питоновский объект.
#. Система генерит конфиг  для списка устройств. Результатом может быть текст, содержащий последовательность CLI-команд, NETCONF XML, набор объектов для YANG, JSONину для gNMI.
#. | Опционально: только что сгенерированные конфиги сохраняются и коммитятся в git-репозиторий. 
   | Здесь же могут выполняться лабораторные тесты CI/CD.
   | Проходят апрувы. 

        Я всё же не верю, что в обозримом будущем на сеть новый конфиг можно катить без человеческого подтверждения, как это давно происходит в мире WEB-приложений.

#. По факту сгенерированного конфига или полученных апрувов формируется задача в Dispatcher для Carrier'а на доставку и применение конфигурации на сеть.

    .. figure:: https://fs.linkmeup.ru/images/adsm/4/step8-9.svg
           :width: 700
           :align: center

#. | Диспетчер диспетчеризирует и следит за выполнением каждой конкретной задачи и всей транзакции целиком.
   | Он целиком и полностью несёт ответственность за то, когда выполняется задача и с каким статусом она завершается. 
#. | В случае успешной транзакции Диспетчер проводит ряд тестов, проверяющих две вещи: 
    
    * Новое устройство готово к обслуживанию трафика,
    * Сеть при этом не сломалась.

            .. figure:: https://fs.linkmeup.ru/images/adsm/4/step10-11.sv
                   :width: 800
                   :align: center

   | Запускаются какие-то пинги. Проверяется маршрутная информация на сети - сравнивается с бейзлайном (например, состояние, как было до деплоя). Последнее предполагает, что мы либо собрали состояние перед обновлением, либо есть некая база данных с временными рядами (TSDB - Time Series Data Base), содержащая срезы исторических данных.
   | Есть тесты, падение которых вызовет аварию, но операция будет считаться завершённой. А есть те, после которых произойдёт автоматический откат всей транзакции. Лучше не сделать ничего, чем сделать хорошо, но наполовину.
#. В случае успешных тестов в NetBox и/или иных системах проставляются индикаторы успешного ввода, новое устройство заводится в мониторинги и другие системы.
#. С результатами Диспетчер идёт в ручку NetAPI и сообщает, что ввод завершён успешно, либо нет.

    .. figure:: https://fs.linkmeup.ru/images/adsm/4/step12.svg
           :width: 600
           :align: center

| Конвейер завершён.
| 
| Это весьма упрощённый конвейер, конечно. Здесь опущены шаги, которые могут быть фактически необходимы в реальной жизни: подавления аварийных сообщений, отписывание комментариев в тикеты, возможные проверки и подтверждения целевой конфигурации живыми людьми, всевозможные валидации на каждом шаге. 

2. Переконфигурация из-за изменений переменных в инвентарной системе
--------------------------------------------------------------------

| Допустим по какой-то причине данные в нашем SoT поменялись - человек руками дескрипшон на порту изменил или автоматика пересчитала LLDP-соседства или ещё что-то.
| Это изменение, которое должно привести к запуску конвейера по вычислению и выкатке новой конфигурации, описанное выше.
| 
| Триггером может быть Web-hook от SoT или опять же кроняка, которая следит за изменениями в этом SoT.
| 
| NetAPI получает запрос на запуск конвейера для вычисления и деплоя новой конфигурации, как это уже было в предыдущем сценарии. 
| Далее повторяются все те же действия, за исключением специфики, присущей вводу новых стоек. Все те же тесты.
| 
| Не забываем про версионирование - изменения переменных в SoT - это изменение версии. Мажорное, минорное или патч - это предмет жарких дискуссий, судьёй которому будет `semver <https://semver.org/>`_.

3. Переконфигурация из-за изменения дизайна
-------------------------------------------

| Это может быть как небольшое изменение политики маршрутизации или ACL, так и сравнительно масштабная вещь, такая как добавление нового типа сервиса на всю сеть.
| В целом, что относить к дизайну, а что к переменным - вопрос не просто дискуссионный, думаю, он на данный момент не имеет точного ответа. 
| 
| Так же вопрос без ответа, в каком виде дизайн должен храниться - питоновские объекты, словарь, yaml, json? Хотел бы знать.
| Но допустим, что независимо от формы он хранится в гите. И тогда его изменение легко можно использовать как триггер для запуска конвейера для вычисления и деплоя новой конфигурации, который мы дважды уже тронули выше.

    Впрочем, тут возможна специфика: изменения дизайна несут риски, поэтому неплохо бы добавить шаг проведения тестов в лабе с помощью CI/CD. 

С точки зрения версионирования - инженер, меняющий дизайн и коммитящий изменения в гит, сам определяет насколько это важное обновление. 

4. Сбор информации с устройств
------------------------------

| В целом сбором информации занимается NetGet. Как периодическим, так и разовым по запросу.
| Поэтому, когда нужно собрать, например, MAC'и с конкретного устройства, клиент идёт в ручку NetAPI, а тот в свою очередь дёргает NetGet.
| 
| NetGet формирует задачу для Диспетчера, чтобы Carrier сходил на устройство и собрал необходимую информацию.
| 
| Учитывая, что для таких запросов клиент ожидает синхронный режим, Диспетчер должен по возможности прогнать его с высоким приоритетом и быстро вернуть ответ NetGet'у.

5. Снятие и возврат нагрузки
----------------------------

| Этот сценарий не является самостоятельным, если мы говорим про окончательное решение вопроса автоматизации - это, скорее, ручка, к которой мы будем обращаться из других сценариев.
| 
| С одной стороны это задача, требующая ультра-много операций, занимающая много времени и склонная к человеческим ошибкам. Допустим какой-нибудь бордер вывести из эксплуатации, для замены контрол-бордов. Явно нужно автоматически это делать.
| С другой - зачастую это работа, требующая весьма интеллектуальной деятельности - поди разбери в нужном порядке разные сервисы, линки, клиенты. 
| 
| Но для сравнительно простых устройств, каковыми являются торы, спайны и суперспайны или один из маршрутизаторов в ISP на резервированном канале, сделать это выглядит несложным.
| 
| Это может быть реализовано как две ручки: для снятия нагрузки и для возврата - так и как одна: выполняющая полный цикл.

#. Клиент приходит в ручку NetAPI. А тот запускает конвейер увода нагрузки
#. Приложение определяет список сервисов, которые нужно погасить (L2/L3VPN, базовая маршрутизация, MPLS итд)
#. | Приложение формирует список действий, которые нужно совершить.
   | Например:

    #. Плавно увести трафик с помощью BGP gshut community или ISIS overload bit (или ещё чего-то
    #. Убедиться в отсутствии трафика на интерфейсах
    #. Выключить BGP-сессии в нужном порядке (сначала сервисные, потом транспортные
    #. Выключить интерфейсы
    #. Убедиться в отсутствии активных аварий по сервисам

#. Зафиксировать статус задачи. 

| Клиент может начинать выполнять запланированные работы. Клиентом может быть другой конвейер.
| 
| По завершению клиент дёргает ту же ручку для возврата нагрузки - и тогда в обратном порядке выполняются предыдущие действия.
| Либо же это отдельная ручка, которая независимо описывает, каким образом для данного типа узлов происходит возврат нагрузки. 
    
6. Обновление ПО
----------------

| Обновление может быть двух видов - требующее прерывания сервисов, и нет.

| Соответственно конвейеры для них будут разные. 
| Рассмотрим для сложного случая

#. Клиент приходит в ручку NetAPI
#. Запускается конвейер снятия нагрузки
#. Запускается конвейер обновления ПО:
    
    #. Залить файлы ПО
    #. Проверить контрольную сумму
    #. Обновить прошивку, указать загрузочные файлы, перезагрузить устройство и провести иные мероприятия
    #. После обновления проверить версию ПО

#. Запустить конвейер возврата нагрузки.


7. Удаление устройства
----------------------

Это весьма частый сценарий. Особенно если рассматривать переезд старого устройства в новую роль или локацию, как удаление и создание нового.

#. Клиент приходит в NetAPI. Тот дёргает приложение, отвечающее за удаление устройства.
#. Приложение проверяет, что нагрузка на устройстве ниже определённого порога.
#. Приложение обращается в NetAPI в ручку снятия нагрузки.
#. Приложение ищет все зависящие от этого устройства объекты в SoT. Как пример:

    #. Интерфейсы
    #. IP-адреса
    #. Подсети
    #. Интерфейсы соседних устройств
    #. P2P-адреса соседних устройств
    #. Итд.

#. Приложение удаляет их все.
#. | Изменения в SoT триггерят запуск уже известного нам конвейера. Как вы видите он весьма и весьма универсален.
   | Как результат - настройки соседних устройств, относящиеся к удалённому, удаляется в процессе деплоя новой конфигурации.
   |  
   | Само же устройство затирается к заводским настройкам. Кроме того оно удаляется из всех мониторингов и других систем.
#. Устройство удаляется из БД или помечается каким-то образом, если нужно сохранить о нём информацию.

8. Замена устройства
--------------------

| Случается, что свитч ломается. Или нужно железку проапгрейдить на новую модель. В общем надо её снять, а новую поставить.
| Теоретически это выглядит как два шага: 

* Удаление текущего устройства
* Добавление нового

Но нам важны несколько вещей:

* Имя нового устройства должно быть таким же, как и у прежнего
* Сохранить MGMT IP
* Сохранить и другие атрибуты: лупбэки, вланы, ASN, итд
* Скорее всего, и конфигурацию

| Не факт, что это всё необходимо, но, скорее всего, так.
| 
| Самым простым выглядит в существующей записи поменять минимум вещей - инвентарник, серийник, модель. Но это лишает гибкости и добавляет несколько щекотливых моментов при выводе старой железки.
| Кроме того, мне импонирует мысль, что девайс в БД собой олицетворяет не место и роль, а вполне конкретное устройство. И при добавлении в сеть нового свитча или роутера, в DCIM появляется новая запись.
| 
| Поэтому я бы всё же рассматривал замену устройства на сети как

* Удаление старого устройства
* Добавление нового с определённым набором атрибутов, значение которых хотим зафиксировать, и которые в противном случае определялись/выделялись бы автоматически.

| При этом процедура удаления, определённая шагом выше, берётся как есть: с удалением артефактов на других устройствах (пересоздадим на втором шаге) и вычисткой конфига с устройства (чтобы, например, оно случайно на новом месте неожиданно не запустилось со старыми адресами и не начало всасывать и блэкхолить трафик).
| Естественно, сценарии этим не ограничиваются. Их количество, степень автоматизированности и результаты диктуются бизнес-логикой и рациональностью.
| 
| Опять же мы тут опускаем вопросы подавления аварийных сообщений, коммита изменений в репы и подобные. 
| 
| Но благодаря такому рассуждению мы приходим к пониманию, что здесь важно заложить наиболее общие и переиспользуемые конвейеры, которые станут впоследствии кирпичиками более сложных задач.
| Сами конвейеры при этом декомпозируются на ещё более простые и универсальные атомы. 
